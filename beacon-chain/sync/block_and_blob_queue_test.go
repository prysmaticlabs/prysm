package sync

import (
	"context"
	"testing"

	"github.com/prysmaticlabs/prysm/v4/consensus-types/blocks"
	"github.com/prysmaticlabs/prysm/v4/encoding/bytesutil"
	eth "github.com/prysmaticlabs/prysm/v4/proto/prysm/v1alpha1"
	"github.com/prysmaticlabs/prysm/v4/testing/require"
	"github.com/prysmaticlabs/prysm/v4/testing/util"
)

func Test_blockAndBlocksQueue(t *testing.T) {
	t.Run("no block", func(t *testing.T) {
		q := newBlockAndBlobs()
		_, err := q.getBlock([32]byte{})
		require.ErrorContains(t, "block does not exist", err)
		canImport, err := q.canImport([32]byte{})
		require.NoError(t, err)
		require.Equal(t, false, canImport)
	})
	t.Run("no blob", func(t *testing.T) {
		q := newBlockAndBlobs()
		_, err := q.getBlob([32]byte{}, 0)
		require.ErrorContains(t, "blob does not exist", err)
		canImport, err := q.canImport([32]byte{})
		require.NoError(t, err)
		require.Equal(t, false, canImport)
	})
	t.Run("has block, no blob", func(t *testing.T) {
		q := newBlockAndBlobs()
		sb, err := blocks.NewSignedBeaconBlock(util.HydrateSignedBeaconBlockDeneb(&eth.SignedBeaconBlockDeneb{}))
		require.NoError(t, err)
		require.NoError(t, q.addBlock(sb))
		_, err = q.getBlob([32]byte{}, 0)
		require.ErrorContains(t, "blob does not exist", err)
		canImport, err := q.canImport([32]byte{})
		require.NoError(t, err)
		require.Equal(t, false, canImport)
	})
	t.Run("has one blob, no block", func(t *testing.T) {
		q := newBlockAndBlobs()
		require.NoError(t, q.addBlob(&eth.BlobSidecar{Index: 1}))
		_, err := q.getBlock([32]byte{})
		require.ErrorContains(t, "block does not exist", err)
		_, err = q.getBlob([32]byte{}, 0)
		require.ErrorContains(t, "blob does not exist", err)
		_, err = q.getBlob([32]byte{}, 2)
		require.ErrorContains(t, "blob does not exist", err)
		_, err = q.getBlob([32]byte{}, 3)
		require.ErrorContains(t, "blob does not exist", err)
		canImport, err := q.canImport([32]byte{})
		require.NoError(t, err)
		require.Equal(t, false, canImport)
	})
	t.Run("has everything", func(t *testing.T) {
		q := newBlockAndBlobs()
		sb, err := blocks.NewSignedBeaconBlock(util.HydrateSignedBeaconBlockDeneb(&eth.SignedBeaconBlockDeneb{Block: &eth.BeaconBlockDeneb{}}))
		require.NoError(t, err)
		b := bytesutil.PadTo([]byte("kzg"), 48)
		require.NoError(t, sb.SetBlobKzgCommitments([][]byte{b, b, b}))
		r, err := sb.Block().HashTreeRoot()
		require.NoError(t, err)
		require.NoError(t, q.addBlock(sb))
		require.NoError(t, q.addBlob(&eth.BlobSidecar{BlockRoot: r[:], Index: 0}))
		require.NoError(t, q.addBlob(&eth.BlobSidecar{BlockRoot: r[:], Index: 1}))
		require.NoError(t, q.addBlob(&eth.BlobSidecar{BlockRoot: r[:], Index: 2}))
		blk, err := q.getBlock(r)
		require.NoError(t, err)
		require.DeepEqual(t, sb, blk)
		blob, err := q.getBlob(r, 0)
		require.NoError(t, err)
		require.Equal(t, uint64(0), blob.Index)
		blob, err = q.getBlob(r, 1)
		require.NoError(t, err)
		require.Equal(t, uint64(1), blob.Index)
		blob, err = q.getBlob(r, 2)
		require.NoError(t, err)
		require.Equal(t, uint64(2), blob.Index)
		canImport, err := q.canImport(r)
		require.NoError(t, err)
		require.Equal(t, true, canImport)
	})
	t.Run("only has higher index", func(t *testing.T) {
		q := newBlockAndBlobs()
		sb, err := blocks.NewSignedBeaconBlock(util.HydrateSignedBeaconBlockDeneb(&eth.SignedBeaconBlockDeneb{Block: &eth.BeaconBlockDeneb{}}))
		require.NoError(t, err)
		b := bytesutil.PadTo([]byte("kzg"), 48)
		require.NoError(t, sb.SetBlobKzgCommitments([][]byte{b, b, b}))
		r, err := sb.Block().HashTreeRoot()
		require.NoError(t, err)
		require.NoError(t, q.addBlock(sb))
		require.NoError(t, q.addBlob(&eth.BlobSidecar{BlockRoot: r[:], Index: 2}))
		blk, err := q.getBlock(r)
		require.NoError(t, err)
		require.DeepEqual(t, sb, blk)
		_, err = q.getBlob(r, 0)
		require.ErrorContains(t, "blob does not exist", err)
		_, err = q.getBlob(r, 1)
		require.ErrorContains(t, "blob does not exist", err)
		blob, err := q.getBlob(r, 2)
		require.NoError(t, err)
		require.Equal(t, uint64(2), blob.Index)
		canImport, err := q.canImport(r)
		require.NoError(t, err)
		require.Equal(t, false, canImport)
	})
}

func Test_blockAndBlocksQueue_missingRootAndIndex(t *testing.T) {
	q := newBlockAndBlobs()
	sb, err := blocks.NewSignedBeaconBlock(util.HydrateSignedBeaconBlockDeneb(&eth.SignedBeaconBlockDeneb{Block: &eth.BeaconBlockDeneb{}}))
	require.NoError(t, err)
	b := bytesutil.PadTo([]byte("kzg"), 48)
	require.NoError(t, sb.SetBlobKzgCommitments([][]byte{b, b, b}))
	require.NoError(t, err)
	require.NoError(t, q.addBlock(sb))
	m, err := q.missingRootAndIndex(context.Background())
	require.NoError(t, err)
	t.Log(m)
}

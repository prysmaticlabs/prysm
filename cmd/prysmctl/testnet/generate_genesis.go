package testnet

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/ghodss/yaml"
	"github.com/pkg/errors"
	fastssz "github.com/prysmaticlabs/fastssz"
	"github.com/prysmaticlabs/prysm/v3/cmd"
	"github.com/prysmaticlabs/prysm/v3/config/params"
	"github.com/prysmaticlabs/prysm/v3/io/file"
	ethpb "github.com/prysmaticlabs/prysm/v3/proto/prysm/v1alpha1"
	"github.com/prysmaticlabs/prysm/v3/runtime/interop"
	"github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
)

var generateGenesisStateCmd = &cli.Command{
	Name:   "generate-genesis",
	Usage:  "Generate a beacon chain genesis state",
	Action: cliActionGenerateGenesisState,
	Flags: []cli.Flag{
		cmd.ChainConfigFileFlag,
		depositJsonFileFlag,
		configNameFlag,
		numValidatorsFlag,
		genesisTimeFlag,
		outputSSZFlag,
		outputYamlFlag,
		outputJsonFlag,
	},
}

var (
	log                 = logrus.WithField("prefix", "genesis")
	depositJsonFileFlag = &cli.StringFlag{
		Name:  "deposit-json-file",
		Value: "",
		Usage: "Path to deposit_data.json file generated by the staking-deposit-cli tool for optionally specifying validators in genesis state",
	}
	configNameFlag = &cli.StringFlag{
		Name:  "config-name",
		Usage: "Config kind to be used for generating the genesis state. Default: mainnet. Options include mainnet, interop, minimal, prater, ropsten, sepolia. --chain-config-file will override this flag.",
		Value: params.MainnetName,
	}
	numValidatorsFlag = &cli.Uint64Flag{
		Name:     "num-validators",
		Usage:    "Number of validators to deterministically generate in the genesis state",
		Required: true,
	}
	genesisTimeFlag = &cli.Uint64Flag{
		Name:  "genesis-time",
		Usage: "Unix timestamp seconds used as the genesis time in the genesis state. If unset, defaults to now()",
	}
	outputSSZFlag = &cli.StringFlag{
		Name:  "output-ssz",
		Usage: "Output filename of the SSZ marshaling of the generated genesis state",
		Value: "",
	}
	outputYamlFlag = &cli.StringFlag{
		Name:  "output-yaml",
		Usage: "Output filename of the YAML marshaling of the generated genesis state",
		Value: "",
	}
	outputJsonFlag = &cli.StringFlag{
		Name:  "output-json",
		Usage: "Output filename of the JSON marshaling of the generated genesis state",
		Value: "",
	}
)

// Represents a json object of hex string and uint64 values for
// validators on Ethereum. This file can be generated using the official staking-deposit-cli.
type depositDataJSON struct {
	PubKey                string `json:"pubkey"`
	Amount                uint64 `json:"amount"`
	WithdrawalCredentials string `json:"withdrawal_credentials"`
	DepositDataRoot       string `json:"deposit_data_root"`
	Signature             string `json:"signature"`
}

func cliActionGenerateGenesisState(cliCtx *cli.Context) error {
	if !cliCtx.IsSet(genesisTimeFlag.Name) {
		log.Infof("No %s specified, defaulting to now()", genesisTimeFlag.Name)
	}
	hasOutputFlag := !cliCtx.IsSet(outputJsonFlag.Name) &&
		!cliCtx.IsSet(outputYamlFlag.Name) &&
		!cliCtx.IsSet(outputSSZFlag.Name)
	if !hasOutputFlag {
		return fmt.Errorf(
			"no %s, %s, or %s flag specified. At least one is required",
			outputJsonFlag.Name,
			outputYamlFlag.Name,
			outputSSZFlag.Name,
		)
	}
	if err := setGlobalParams(cliCtx); err != nil {
		return fmt.Errorf("could not set config params: %v", err)
	}
	genesisState, err := generateGenesis(cliCtx)
	if err != nil {
		return fmt.Errorf("could not generate genesis state: %v", err)
	}
	outputJson := cliCtx.String(outputJsonFlag.Name)
	outputYaml := cliCtx.String(outputYamlFlag.Name)
	outputSSZ := cliCtx.String(outputSSZFlag.Name)
	if outputJson != "" {
		if err := writeToOutputFile(outputJson, genesisState, json.Marshal); err != nil {
			return err
		}
	}
	if outputYaml != "" {
		if err := writeToOutputFile(outputJson, genesisState, yaml.Marshal); err != nil {
			return err
		}
	}
	if outputSSZ != "" {
		marshalFn := func(o interface{}) ([]byte, error) {
			marshaler, ok := o.(fastssz.Marshaler)
			if !ok {
				return nil, errors.New("not a marshaler")
			}
			return marshaler.MarshalSSZ()
		}
		if err := writeToOutputFile(outputSSZ, genesisState, marshalFn); err != nil {
			return err
		}
	}
	log.Info("Command completed")
	return nil
}

func setGlobalParams(cliCtx *cli.Context) error {
	configFilePath := cliCtx.String(cmd.ChainConfigFileFlag.Name)
	configName := cliCtx.String(configNameFlag.Name)
	if configFilePath != "" {
		log.Infof("Specified a chain config file: %s", configFilePath)
		return params.LoadChainConfigFile(configFilePath, nil)
	}
	cfg, err := params.ByName(configName)
	if err != nil {
		return fmt.Errorf("unable to find config using name %s: %v", configName, err)
	}
	return params.SetActive(cfg.Copy())
}

func generateGenesis(cliCtx *cli.Context) (*ethpb.BeaconState, error) {
	genesisTime := cliCtx.Uint64(genesisTimeFlag.Name)
	depositJsonFile := cliCtx.String(depositJsonFileFlag.Name)
	if depositJsonFile != "" {
		expanded, err := file.ExpandPath(depositJsonFile)
		if err != nil {
			return nil, err
		}
		inputJSON, err := os.Open(expanded) // #nosec G304
		if err != nil {
			return nil, err
		}
		defer func() {
			if err := inputJSON.Close(); err != nil {
				log.WithError(err).Printf("Could not close file %s", depositJsonFile)
			}
		}()
		log.Printf("Generating genesis state from input JSON deposit data %s", depositJsonFile)
		return genesisStateFromJSONValidators(cliCtx.Context, inputJSON, genesisTime)
	}
	numValidators := cliCtx.Uint64(numValidatorsFlag.Name)
	if numValidators == 0 {
		return nil, fmt.Errorf(
			"expected %s > 0 to have been provided",
			numValidatorsFlag.Name,
		)
	}
	// If no JSON input is specified, we create the state deterministically from interop keys.
	genesisState, _, err := interop.GenerateGenesisState(cliCtx.Context, genesisTime, numValidators)
	if err != nil {
		return nil, err
	}
	return genesisState, err
}

func genesisStateFromJSONValidators(ctx context.Context, r io.Reader, genesisTime uint64) (*ethpb.BeaconState, error) {
	enc, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}
	var depositJSON []*depositDataJSON
	if err := json.Unmarshal(enc, &depositJSON); err != nil {
		return nil, err
	}
	depositDataList := make([]*ethpb.Deposit_Data, len(depositJSON))
	depositDataRoots := make([][]byte, len(depositJSON))
	for i, val := range depositJSON {
		data, dataRootBytes, err := depositJSONToDepositData(val)
		if err != nil {
			return nil, err
		}
		depositDataList[i] = data
		depositDataRoots[i] = dataRootBytes
	}
	beaconState, _, err := interop.GenerateGenesisStateFromDepositData(ctx, genesisTime, depositDataList, depositDataRoots)
	if err != nil {
		return nil, err
	}
	return beaconState, nil
}

func depositJSONToDepositData(input *depositDataJSON) (depositData *ethpb.Deposit_Data, dataRoot []byte, err error) {
	pubKeyBytes, err := hex.DecodeString(strings.TrimPrefix(input.PubKey, "0x"))
	if err != nil {
		return
	}
	withdrawalbytes, err := hex.DecodeString(strings.TrimPrefix(input.WithdrawalCredentials, "0x"))
	if err != nil {
		return
	}
	signatureBytes, err := hex.DecodeString(strings.TrimPrefix(input.Signature, "0x"))
	if err != nil {
		return
	}
	dataRootBytes, err := hex.DecodeString(strings.TrimPrefix(input.DepositDataRoot, "0x"))
	if err != nil {
		return
	}
	depositData = &ethpb.Deposit_Data{
		PublicKey:             pubKeyBytes,
		WithdrawalCredentials: withdrawalbytes,
		Amount:                input.Amount,
		Signature:             signatureBytes,
	}
	dataRoot = dataRootBytes
	return
}

func writeToOutputFile(
	fPath string,
	data interface{},
	marshalFn func(o interface{}) ([]byte, error),
) error {
	encoded, err := marshalFn(data)
	if err != nil {
		return err
	}
	if err := file.WriteFile(fPath, encoded); err != nil {
		return err
	}
	log.Printf("Done writing genesis state to %s", fPath)
	return nil
}
